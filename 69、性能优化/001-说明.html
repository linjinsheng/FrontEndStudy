<!DOCTYPE html>
<html>
  <head>
    <title>DEMO</title>
  </head>
  <body>
    <div id="container"> 
    </div>
    
    <script>
    console.log('*******************************')
    /**
      一、初始阶段———>加载优化
      1、首页加载慢的优化
      
      问题1:
      1.1 首页加载图片太多;
      1.2 首页请求量太多
      1.3 首页请求的静态资源(html、css、js、图片)过大
      1.4 网速不好、电脑太渣

      1.1 首页加载图片太多采取措施:
      1)、通过懒加载来减少首屏图片的加载量
      2)、针对纯色系小图标设置font-family的css属性;
      3)、针对彩色的小图片可以采用雪碧图: 把所有小图片拼接到一张大图片上,
      并且使用background-position的css属性来修改图片坐标;

      1.2 首页请求量太多采取措施:
      1)、通过浏览器的Network来确定首页加载的资源和请求量
      2)、通过coverage来查看代码的使用情况(只针对JS和CSS)
      3)、可以通过nginx来做资源文件合并,将多个Javascript、CSS文件合并;
      4)、通过webpack打包工具来进行物理打包;
      5)、按需加载组件库;
      6)、在路由层面也可以使用React lazy进行动态路由的加载，从而可以减少首页的JS和CSS的大小

      1.3 首页请求的资源（CSS、JS、图片）过大采取的措施:
      1)、要分资源文件，CSS，JS，图片等要分开来处理
      2)、CSS和JS 可以通过 Webpack来进行
        混淆：将 JS 代码进行字符串加密
        压缩：去除注释空行以及console.log等调试代码
      3)、图片进行压缩
      4)、可在服务器端开启gzip压缩来最大化减少所有文件体积

      ***************************************************
      ***************************************************

      2、优化图片
      优化目标: 减少图片的请求,减少图片的大小
      1)、使用自动化工具(熊猫站)对图片进行等比例无损压缩(主要通过减少颜色的数量和不必要的数据来实现文件压缩)
      2)、对小图片进行base64的转码;
      3)、比较大的图片,使用自动化压缩工具webpack中的file-loader单独打包到img文件中,
        发送请求,防止首页渲染太慢;
      4)、使用webp格式的图片;

      ***************************************************
      ***************************************************

      3、实现webpack打包优化
      目标: 减小包的数量; 减小包的体积;
      1)、development：不混淆，不压缩，不优化
        production：混淆 + 压缩，自动内置优化
        将mode改成production即可;
      2)、使用Webpack + dynamic import 并结合路由的入口文件做拆包处理。
        第三方包：改动频率 -- 小
        公共代码包：改动频率 -- 中
        非公共代码包：改动频率 -- 高
      3)、设定一些打包策略，并配合网络缓存做最终的加载性能优化

      4、实现CDN加速
      CDN 服务器主要是用来放静态资源的服务器，可以用来**加速**静态资源的下载
      CDN 之所以能够加速，是因为会在很多地方都部署 CDN 服务器，如果用户需要下载静态资源，
      会自动选择最近的节点下载
      CDN 服务器的地址一般都跟主服务器的地址不同，所以可以破除浏览器对同一个域名发送请求的限制
      (对于同一个协议、域名、端口，浏览器允许同时打开最多6个TCP连接（最多同时发送 6个请求))


      二、运行阶段———渲染优化
      渲染很多条数据会造成浏览器卡顿的原因:
      1、无论是浏览器中的DOM和BOM,还是 NodeJS，它们都是基于JavaScript引擎之上开发出来的;
      2、DOM和BOM的处理最终都是要被转换成JavaScript引擎能够处理的数据;
      3、这个转换的过程很耗时
      4、在浏览器中最消耗性能的就是操作DOM

      优化渲染很多数据的情况:
      指导原则：尽可能的减少DOM的操作
     */
    </script>
  </body>
</html>
