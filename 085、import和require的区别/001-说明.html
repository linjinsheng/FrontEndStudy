<!DOCTYPE html>
<html>
  <head>
    <title>DEMO</title>
  </head>
  <body>
    <div id="container"> 
    </div>
    
    <script>
    console.log('*******************************')
    /**
    https://blog.csdn.net/weixin_38173313/article/details/81205395?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&utm_relevant_index=1
    import和require的区别
    一、遵守规范
    require 是 AMD规范引入方式
    import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法;

    二、调用时间
    require是运行时调用，所以require理论上可以运用在代码的任何地方，require可以理解为一个全局方法
    import是编译时调用，所以必须放在文件开头

    三、本质
    require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量
    import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，
    import语法会被转码为require
    
    四、语法
    require / exports ：遵循 CommonJS/AMD，只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。
    const fs = require('fs')
    exports.fs = fs
    module.exports = fs

    import / export：遵循 ES6 规范，支持编译时静态分析，便于JS引入宏和类型检验。动态绑定。
    import fs from 'fs'
    import {default as fs} from 'fs'
    import * as fs from 'fs'
    import {readFile} from 'fs'
    import {readFile as read} from 'fs'
    import fs, {readFile} from 'fs'

    export default fs
    export const fs
    export function readFile
    export {readFile, read}
    export * from 'fs'

    五、数据导出
    通过require引入基础数据类型时，属于复制该变量。通过require引入复杂数据类型时，数据浅拷贝该对象。

    */
    </script>
  </body>
</html>
